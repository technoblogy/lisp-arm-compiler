; Lisp compiler to ARM Thumb Assembler - Version 1 - 6th August 2024;;; Compile a lisp function(defun compiler (name)  (if (eq (car (eval name)) 'lambda)    (eval (comp (cons 'defun (cons name (cdr (eval name)))))) (error "Not a Lisp function"))); The main compile routine - returns compiled code for x, prefixed by type :integer or :boolean(defun comp (x &optional env)  (cond   ((null x) (type-code :boolean '(($mov 'r0 0) ($push '(r0)))))   ((eq x t) (type-code :boolean '(($mov 'r0 1) ($push '(r0)))))   ((symbolp x) (comp-symbol x env))   ((atom x) (type-code :integer (list (list '$mov ''r0 x) '($push '(r0)))))   (t (let ((fn (first x)) (args (rest x)))        (case fn          (defun (setq *label-num* 0)                 (setq env (mapcar #'(lambda (x y) (cons x y)) (second args) *locals*))                 (comp-defun args env))          (progn (comp-progn args env))          (if    (comp-if (first args) (second args) (third args) env))          (setq  (comp-setq args env))          (t     (comp-funcall fn args env))))))); Utilities; Like mapcon but not destructive(defun mappend (fn lst)  (apply #'append (mapcar fn lst))); The type is prefixed onto the list of assembler code instructions(defun type-code (type code) (cons type code))(defun code-type (type-code) (car type-code))(defun code (type-code) (cdr type-code))(defun checktype (fn type check)  (unless (eq type check)    (error "Argument to '~a' must be ~a not ~a~%" fn type check))); Allocate registers(defvar *params* '(r0 r1 r2 r3))(defvar *locals* '(r4 r5 r6 r7)); Generate a label(defvar *label-num* 0)(defun gen-label ()  (read-from-string (format nil "lab~d" (incf *label-num*)))); Subfunctions(defun comp-symbol (x env)  (let ((reg (cdr (assoc x env))))    (type-code :integer (list (list '$push (list 'quote (list reg)))))))(defun comp-setq (args env)  (let ((value (comp (second args) env))        (reg (cdr (assoc (first args) env))))    (type-code      (code-type value)      (append (code value) (list '($pop '(r0)) (list '$mov (list 'quote reg) ''r0) '($push '(r0)))))))(defun comp-defun (args env)  (append    (list 'defcode (first args) (second args))   (list (first args))   '(($push '(lr r7 r6 r5 r4)))   (subseq '(($mov 'r4 'r0) ($mov 'r5 'r1) ($mov 'r6 'r2) ($mov 'r7 'r3)) 0 (length (second args)))   (code (comp-progn (cddr args) env))   '(($pop '(r0 r4 r5 r6 r7 pc)))))(defun comp-progn (exps env)  (let* ((len (1- (length exps)))         (nlast (subseq exps 0 len))         (last1 (nth len exps))         (start (mappend #'(lambda (x) (append (code (comp x env)) '(($pop '(r0))))) nlast))         (end (comp last1 env)))    (type-code (code-type end) (append start (code end)))))(defun comp-if (pred then else env)  (let ((lab1 (gen-label))        (lab2 (gen-label))        (test (comp pred env)))    (checktype 'if (car test) :boolean)    (type-code :integer           (append             (code test) (list '($pop '(r0)) '($cmp 'r0 0) (list '$beq lab1))             (code (comp then env)) (list (list '$b lab2))             (list lab1) (code (comp else env))             (list lab2)))))(defun comp-funcall (f args env)  (let ((comparison (assoc f '((> . $bgt) (>= . $bge) (= . $beq)                               (<= . $ble) (< . $blt) (/= . $bne))))        (logical (assoc f '((and . $and) (or . $orr))))        (arithmetic (assoc f '((+ . $add) (- . $sub) (* . $mul)                                (logand . $and) (logior . $orr) (logxor . $eor)))))    (cond     (comparison      (let ((label (gen-label)))        (type-code :boolean               (append                (comp-args f args :integer env)                (list '($pop '(r0 r1)) '($mov 'r2 1) '($cmp 'r1 'r0)                       (list (cdr comparison) label) '($mov 'r2 0) label '($push '(r2)))))))     (logical       (type-code :boolean             (append              (comp-args f args :boolean env)              (pop-push (list (cdr logical) ''r1 ''r0)))))     (arithmetic      (type-code :integer              (append              (comp-args f args :integer env)              (pop-push (list (cdr arithmetic) ''r1 ''r0)))))     (t ; function call      (type-code :integer              (append              (comp-args f args :integer env)              (mappend                #'(lambda (x) (list (list '$pop (list 'quote (list x)))))               (reverse (subseq *params* 0 (length args))))              (list (list '$bl f) '($push '(r0)))))))))(defun comp-args (fn args type env)  (mappend #'(lambda (y)               (let ((c (comp y env)))                 (checktype fn type (car c))                 (cdr c)))           args))(defun pop-push (&rest sequence)  (append (list '($pop '(r0 r1))) sequence (list '($push '(r1))))); Compile each expression and discard all results except the last one; Examples(defun gcd* (x y)  (if (= x y) x   (if (> x y) (gcd* (- x y) y)    (gcd* x (- y x)))))(defun fact (n)  (if (<= n 1) 1    (* n (fact (- n 1)))))(defun q (n)  (if (<= n 2) 1    (+     (q (- n (q (- n 1))))     (q (- n (q (- n 2)))))))(defun big (x)  (if (<= x 0) 2    (let ((k (big (- x 1))))      (* k k))))(defun fib (n)  (if (< n 3) 1    (+ (fib (- n 1)) (fib (- n 2)))))(defun rec (n)  (+ 1 (* n (if (= n 0) 0 (rec (- n 1))))))(defun fact2 (m n)  (if (<= (+ m n) 1) 1    (* (+ m n) (fact2 (- m 1) (- n 1)))))(defun q2 (x y)  (if (or (< x 1) (< y 1)) 1    (+ (q2 (- x (q2 (- x 1) y)) y)       (q2 x (- y (q2 x (- y 1))))))); Not work yet(defun factor (n &optional (d 2))  (let ((d 2) (i 1))    (loop     (when (> (* d d) n) (return n))     (when (zerop (mod n d)) (return d))     (incf d i) (setq i 2))))(defun r-logand (n)  (+ n (logand n (if (= n 0) 0 (r-logand (1- n))))))  